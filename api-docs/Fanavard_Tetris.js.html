

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Source: Fanavard/Tetris.js | Fanavard TetrisGame</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/bootstrap.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-jsdoc.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/tui-doc.css">

    
        
            <link type="text/css" rel="stylesheet" href="styles/custom.css">
        
    
</head>
<body>
<nav class="lnb" id="lnb">
    <div class="logo" style="width: 200px; height: 85px">
        
            <a href="#" rel="noopener noreferrer" target="_blank">
                <img src="./img/logo.png" width="100%" height="100%">
            </a>
        
    </div>
    <div class="title">
        <h1><a href="index.html" class="link">Fanavard TetrisGame</a></h1>
        
    </div>
    <div class="search-container" id="search-container">
        <input type="text" placeholder="Search">
        <ul></ul>
    </div>
    
    <div class="lnb-api hidden"><h3>Classes</h3><ul><li><a href="Charblock.html">Charblock</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="Charblock_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="Charblock.html#.destroy">destroy</a></li><li><a href="Charblock.html#.factory">factory</a></li><li><a href="Charblock.html#.getNew">getNew</a></li><li><a href="Charblock.html#.move">move</a></li><li><a href="Charblock.html#.showUpComingChar">showUpComingChar</a></li></ul></div></li><li><a href="Interval.html">Interval</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="Interval_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="Interval.html#clear">clear</a></li><li><a href="Interval.html#clearAll">clearAll</a></li><li><a href="Interval.html#make">make</a></li></ul></div></li><li><a href="MaterialColor.html">MaterialColor</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="MaterialColor_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="MaterialColor.html#.getRandomColor">getRandomColor</a></li><li><a href="MaterialColor.html#.pickRandomProperty">pickRandomProperty</a></li></ul></div></li><li><a href="Matrix.html">Matrix</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="Matrix_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="Matrix.html#_deleteCharacters">_deleteCharacters</a></li><li><a href="Matrix.html#_getRailingChars">_getRailingChars</a></li><li><a href="Matrix.html#checkWords">checkWords</a></li><li><a href="Matrix.html#setCharacter">setCharacter</a></li></ul></div></li><li><a href="Modal.html">Modal</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="Modal_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="Modal.html#createContent">createContent</a></li><li><a href="Modal.html#createFooter">createFooter</a></li><li><a href="Modal.html#createHeader">createHeader</a></li><li><a href="Modal.html#destroy">destroy</a></li><li><a href="Modal.html#show">show</a></li></ul></div></li><li><a href="Sound.html">Sound</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="Sound_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="Sound.html#.getInstance">getInstance</a></li><li><a href="Sound.html#.makeInstanceName">makeInstanceName</a></li><li><a href="Sound.html#.playByKey">playByKey</a></li><li><a href="Sound.html#.setInstance">setInstance</a></li><li><a href="Sound.html#pause">pause</a></li><li><a href="Sound.html#play">play</a></li></ul></div></li><li><a href="Storage.html">Storage</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="Storage_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="Storage.html#.get">get</a></li><li><a href="Storage.html#.getInt">getInt</a></li><li><a href="Storage.html#.getJson">getJson</a></li><li><a href="Storage.html#.set">set</a></li></ul></div></li><li><a href="Swipe.html">Swipe</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="Swipe_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="Swipe.html#buildListeners">buildListeners</a></li><li><a href="Swipe.html#destroy">destroy</a></li><li><a href="Swipe.html#onTouchEnd">onTouchEnd</a></li><li><a href="Swipe.html#onTouchStart">onTouchStart</a></li><li><a href="Swipe.html#whileTouch">whileTouch</a></li></ul></div></li><li><a href="TetrisGame.html">TetrisGame</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="TetrisGame_sub"><div class="member-type">Members</div><ul class="inner"><li><a href="TetrisGame.html#config">config</a></li><li><a href="TetrisGame.html#initValues">initValues</a></li><li><a href="TetrisGame.html#playBoard">playBoard</a></li></ul><div class="member-type">Methods</div><ul class="inner"><li><a href="TetrisGame.html#.build">build</a></li><li><a href="TetrisGame.html#.checkWordSuccess">checkWordSuccess</a></li><li><a href="TetrisGame.html#.getValidColumnsNumber">getValidColumnsNumber</a></li></ul></div></li><li><a href="Timer.html">Timer</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="Timer_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="Timer.html#pause">pause</a></li><li><a href="Timer.html#resume">resume</a></li><li><a href="Timer.html#start">start</a></li></ul></div></li></ul></div><div class="lnb-api hidden"><h3>Global</h3><ul><li><a href="global.html#addLanguage">addLanguage</a></li><li><a href="global.html#allowedInitTypes">allowedInitTypes</a></li><li><a href="global.html#allowInit">allowInit</a></li><li><a href="global.html#arshLoader">arshLoader</a></li><li><a href="global.html#build">build</a></li><li><a href="global.html#buildDummy">buildDummy</a></li><li><a href="global.html#buildPlugIns">buildPlugIns</a></li><li><a href="global.html#checkLoad">checkLoad</a></li><li class="hidden"><a href="global.html#CheckTypes">CheckTypes</a></li><li><a href="global.html#debugMode">debugMode</a></li><li><a href="global.html#deepExtend">deepExtend</a></li><li><a href="global.html#defaultLoadProperties">defaultLoadProperties</a></li><li><a href="global.html#defaultType">defaultType</a></li><li><a href="global.html#deleteNode">deleteNode</a></li><li><a href="global.html#disableCache">disableCache</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#isFunction">isFunction</a></li><li><a href="global.html#jRun">jRun</a></li><li><a href="global.html#loadedFiles">loadedFiles</a></li><li><a href="global.html#notAllowedUserAttributes">notAllowedUserAttributes</a></li><li><a href="global.html#plugins">plugins</a></li><li class="hidden"><a href="global.html#RailingChars">RailingChars</a></li><li><a href="global.html#reverse">reverse</a></li><li><a href="global.html#sanitizeName">sanitizeName</a></li><li><a href="global.html#setLoadedFlag">setLoadedFlag</a></li><li><a href="global.html#TetrisWords">TetrisWords</a></li><li class="hidden"><a href="global.html#TimerConfig">TimerConfig</a></li><li><a href="global.html#urlPrefix">urlPrefix</a></li><li><a href="global.html#version">version</a></li></ul></div>
</nav>
<div id="resizer"></div>

<div class="main" id="main">
    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* jshint browser: true */


const CONTROL_CODES = {
    DOWN: 40,
    LEFT: 37,
    RIGHT: 39
};


/**
 * Delete node with animation
 * @param row
 * @param column
 */
function deleteNode(row , column){

    let deleteTiming = 0;
    let domToDelete = document.querySelector(`.row_${row} .column_${column} .charBlock`);
    let gameConfig = TetrisGame.config;

    if(gameConfig.useAnimationFlag) {
        let animateClass =  "animatedOneSecond";
        deleteTiming = gameConfig.simpleFallDownAnimateSpeed;
        if(gameConfig.level === 3){
            deleteTiming = gameConfig.expertFallDownAnimateSpeed;
            animateClass = "animated";
        }else if(gameConfig.level === 2){
            deleteTiming = gameConfig.mediumFallDownAnimateSpeed;
            animateClass = "animatedHalfSecond";
        }
        domToDelete.classList.add(animateClass , "zoomOutDown");
    }

    setTimeout(
        () => {
            domToDelete.parentNode.removeChild(domToDelete);
        }, deleteTiming
    );

}




//==================[WORD FINDING RELATED FUNCTIONS]=========================


//Row     -> y
//Column  -> x
function getRailingChars(matrix,y,x,direction){
    const width = matrix[0].length;
    const height = matrix.length;

    let railingChars='';
    // let from=-1,to=-1;//from and to determines location from
    let len=0;//Determines how much did we move in each direction to get to space or end of direction

    let i=1;//i is just the iterator in loops
    switch(direction){
        case 'R':
            //Go in Right direction
            //i starts with 1 because we dont want the current character
            //This loop will go to right until it reaches the border OR next character is ' '
            //Rest of cases are just like this method but with differnt direction
            // from=1+x;
            for(i=1;i+x&lt;width &amp;&amp; matrix[y][i+x]!==' ';i++){
                railingChars+=matrix[y][i+x];
                // to=i+x;
                len++;
            }
            break;
        case 'L':
            // from=x-1;
            for(i=1;x-i>=0 &amp;&amp; matrix[y][x-i]!==' ';i++){
                railingChars=matrix[y][x-i] + railingChars;
                // to=x-i;
                len++;
            }
            break;
        case 'T':
            // from=y-1;
            for(i=1;y-i>=0 &amp;&amp; matrix[y-i][x]!==' ';i++){
                railingChars+=matrix[y-i][x];
                // to=y-i;
                len++;
            }
            break;
        case 'D':
            // from=y+1;
            for(i=1;y+i&lt;height &amp;&amp; matrix[y+i][x]!==' ';i++){
                railingChars+=matrix[y+i][x];
                // to=y+i;
                len++;
            }
            break;
    }

    return {
        chars:railingChars,
        // to:to,
        // from:from,
        len:len
    }
}






/**
 Reversing strings containing especial unicode characters can cause problems using usual ways to reverse!
 For example this string: 'foo ðŒ† bar maÃ±ana manÌƒana' will be corrupt if used string.split("").reverse().join("");
 We'll use following code from mathiasbynens to reverse a string properly
 https://github.com/mathiasbynens/esrever/blob/master/src/esrever.js
 */
function reverse(string) {
    let regexSymbolWithCombiningMarks = /(&lt;%= allExceptCombiningMarks %>)(&lt;%= combiningMarks %>+)/g;
    let regexSurrogatePair = /([\uD800-\uDBFF])([\uDC00-\uDFFF])/g;
    // Step 1: deal with combining marks and astral symbols (surrogate pairs)
    string = string
    // Swap symbols with their combining marks so the combining marks go first
        .replace(regexSymbolWithCombiningMarks, function($0, $1, $2) {
            // Reverse the combining marks so they will end up in the same order
            // later on (after another round of reversing)
            return reverse($2) + $1;
        })
        // Swap high and low surrogates so the low surrogates go first
        .replace(regexSurrogatePair, '$2$1');
    // Step 2: reverse the code units in the string
    let result = [];
    let index = string.length;
    while (index--) {
        result.push(string.charAt(index));
    }
    return result.join('');
}

function checkSuccess(matrix,words,rowId,colId,successCallback){

    let rights = getRailingChars(matrix,rowId,colId,'R');
    let lefts = getRailingChars(matrix,rowId,colId,'L');
    let tops = getRailingChars(matrix,rowId,colId,'T');
    let downs = getRailingChars(matrix,rowId,colId,'D');

    // const sentenceLTR = excapeRegex(lefts + matrix[9][2] + rights);
    // const sentenceTTD = excapeRegex(tops  + matrix[9][2] + downs);
    // const sentenceRTL = excapeRegex(reverse(sentenceLTR));
    // const sentenceDDT = excapeRegex(reverse(sentenceTTD));
    const sentenceLTR = (lefts.chars + matrix[rowId][colId] + rights.chars);
    const sentenceTTD = (tops.chars  + matrix[rowId][colId] + downs.chars);
    const sentenceRTL = (reverse(sentenceLTR));
    const sentenceDTT = (reverse(sentenceTTD));
    // console.log(sentenceLTR);
    console.log(sentenceRTL);
    //
    // const regexLTR = new RegExp(sentenceLTR,'i');
    // const regexTTD = new RegExp(sentenceTTD,'i');
    // const regexRTL = new RegExp(sentenceRTL,'i');
    // const regexDDT = new RegExp(sentenceDDT,'i');

    let checkType={rtl:true,ltr:true,ttd:false,dtt:false};

    for(let i=0, len=words.length; i &lt; len; i++){
        let pos,
            word = words[i].word
        ;
        if(checkType.ltr &amp;&amp; (pos=sentenceLTR.indexOf(word)) !== -1){
            console.log("LTR: Found valid word:"+ word +" In:" + sentenceLTR);
            let startFrom = colId-lefts.len+pos;
            deleteCharacters(matrix,rowId,colId,'ltr',startFrom,word.length);
            Sound.playByKey('foundWord',TetrisGame.config.playEventsSound);
            //TODO: Increase Score
            //TODO: Remove Chars from TetrisGame.initValues.choosedWordsUsedChars
            //TODO: Remove Words from TetrisGame.initValues.choosedWords
        }else if(checkType.rtl &amp;&amp; (pos=sentenceRTL.indexOf(word)) !== -1){
            console.log("RTL: Found valid word:"+ word +" In:" + sentenceRTL);

            let startFrom = colId+rights.len-pos;
            deleteCharacters(matrix,rowId,colId,'rtl',startFrom,word.length);
            Sound.playByKey('foundWord',TetrisGame.config.playEventsSound);

        }else if (checkType.rtl &amp;&amp; sentenceRTL.indexOf(word) !== -1){
            console.log("Found valid word:"+ word +" In:" + sentenceRTL)
        }else if (checkType.dtt &amp;&amp; sentenceDTT.indexOf(word) !== -1){
            console.log("Found valid word:"+ word +" In:" + sentenceDTT)
        }
    }
}



function deleteCharacters(matrix,rowId,colId,checkType,occurancePositionFrom,occurancePositionLenght){


    if(checkType==='ltr'){
        //Clear characters in matrix
        for(let c=0,i = occurancePositionFrom;i&lt;occurancePositionFrom+occurancePositionLenght;i++,c++){
            matrix[rowId][i]=' ';

            setTimeout(()=>{deleteNode(rowId , i)},c*200);


            //Move upper blocks to bottom
            for(let upIndex=rowId;matrix[upIndex-1][i] !== ' ' &amp;&amp; upIndex>=0;upIndex--){
                matrix[upIndex][i] = matrix[upIndex-1][i];
                matrix[upIndex-1][i] = ' ';
                //TODO: Apply falling animations for moving chars from [upIndex-1][i] to [upIndex][i]
            }
        }
    }else if (checkType==='rtl'){
        //Clear characters in matrix
        for(let c=0,i=occurancePositionFrom;i>occurancePositionFrom-occurancePositionLenght;--i,++c){
            matrix[rowId][i]=' ';

            setTimeout(()=>{deleteNode(rowId , i)},c*200);
            // deleteNode(rowId , i,c*200);

            //Move upper blocks to bottom
            for(let upIndex=rowId;matrix[upIndex-1][i] !== ' ' &amp;&amp; upIndex>=0;upIndex--){
                matrix[upIndex][i] = matrix[upIndex-1][i];
                matrix[upIndex-1][i] = ' ';
                //TODO: Apply falling animations for moving chars from [upIndex-1][i] to [upIndex][i]
            }
        }
    }else if (checkType==='ttd'){
        //TODO
    }else if (checkType==='dtt'){
        //TODO
    }
}

//==================[END OF WORD FINDING RELATED FUNCTIONS]=====================













(function () {

    'use strict';

    let TetrisGame,blobTiming;

    /**
     * //TODO: Execute this before anything else
     * Create Object.assign method if it's not supported by default
     */
    if (!Object.assign) {
        Object.defineProperty(Object, 'assign', {
            enumerable: false,
            configurable: true,
            writable: true,
            value: function (target) {
                if (target === undefined || target === null) {
                    throw new TypeError('Cannot convert first argument to object');
                }

                let to = Object(target);
                for (let i = 1; i &lt; arguments.length; i++) {
                    let nextSource = arguments[i];
                    if (nextSource === undefined || nextSource === null) {
                        continue;
                    }
                    nextSource = Object(nextSource);

                    let keysArray = Object.keys(nextSource);
                    for (let nextIndex = 0, len = keysArray.length; nextIndex &lt; len; nextIndex++) {
                        let nextKey = keysArray[nextIndex];
                        let desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                        if (desc !== undefined &amp;&amp; desc.enumerable) {
                            to[nextKey] = nextSource[nextKey];
                        }
                    }
                }
                return to;
            }
        });
    }


    /**
     * Tetris game
     */
    TetrisGame = {

        /**
         * Current version
         */
        version: '0.1.11',


        /**
         * Base config for game
         */
        config: {
            rows: 11,
            columnsMin: 6,
            columnsMax: 16,
            workingWordCount: 1,
            charSpeed: 1000,                 // 1 second - get division to level when making game harder
            checkInRow: true,
            checkInColumn: false,
            useLowercase: false,
            simpleFallDownAnimateSpeed : 700,
            mediumFallDownAnimateSpeed : 500,
            expertFallDownAnimateSpeed : 200,

            // user setting values
            playBackgroundSound: true,
            playEventsSound: true,
            level: 1 ,                       // up to 3 - if it is big it is hard to play
            useAnimationFlag : false,        // make animate or not
            showGrids : true                 // show grids flag
        },


        /**
         * We hold game variables here
         */
        initValues: {
            paused: false,                  // is game paused
            finished: false,                // is game finished
            wordsFinished: false,           // do we run out of words
            chooseedWordKind: {},           // holds user words kind
            bgSound : null ,                // background sound instance
            isFirstRun: true,               // is this my first run

            validatedColumnsCount: 0,       // Count of columns which are validated
            nextChar: '',                   // Next character
            activeChar: {},                 // Active character [not stopped] Object index
            choosedWords: [],               // Choosed words to work with them
            choosedWordsUsedChars: []       // Chars that used from choosed words
        },


        /**
         * Are we in browser env
         */
        isBrowser: (typeof window !== 'undefined'),


        /**
         * Game play board
         */
        playBoard: null,


        /**
         * Class Use to add new coming block
         */
        charBlock: function () {


            // if game is finished
            if (TetrisGame.initValues.finished) {
                document.querySelector(".showUpComingLetter").innerHTML = "";
                return false;
            }

            let charBlock = {};

            // choose random column to init char
            charBlock.column = Math.random() * TetrisGame.initValues.validatedColumnsCount &lt;&lt; 0;
            charBlock.row = 0;                               // top is 0 and bottom is max
            charBlock.name = TetrisGame.initValues.nextChar === "" ? TetrisGame.chooseChar() : TetrisGame.initValues.nextChar;        // char value
            charBlock.color = MaterialColor.getRandomColor();    // random material color
            charBlock.active = true;                         // character is animating on air
            charBlock.element = null;                        // holds our character element


            // move char
            charBlock.move = function (eventKeyCode , position) {

                let moveTo = {},isBottomMove = false;


                switch (eventKeyCode) {
                    case TetrisGame.controlCodes.LEFT:  // left
                        moveTo = {
                            row: charBlock.row,
                            column: charBlock.column + 1,
                            animateOutClass: (lang.rtl ? "fadeOutLeft" : "fadeOutRight"),
                            animateInClass: (lang.rtl ? "fadeInRight" : "fadeInLeft")
                        };
                        break;
                    case TetrisGame.controlCodes.RIGHT:  // right
                        moveTo = {
                            row: charBlock.row,
                            column: charBlock.column - 1,
                            animateOutClass: (lang.rtl ? "fadeOutRight" : "fadeOutLeft"),
                            animateInClass: (lang.rtl ? "fadeInLeft" : "fadeInRight")
                        };
                        break;
                    case TetrisGame.controlCodes.DOWN:  // down
                        moveTo = {
                            row: charBlock.row + 1,
                            column: charBlock.column,
                            animateOutClass: "fadeOutDown",
                            animateInClass: "fadeInDown"
                        };
                        isBottomMove = true;
                        break;
                    default:

                        // do we have forced position
                        if(typeof position !== "undefined"){
                            moveTo = {
                                row: position.x,
                                column: position.y ,
                                animateOutClass: "fadeOutDown",
                                animateInClass: "fadeInDown"
                            };
                        }else {
                            console.log("Unable to determine move !");
                            return false;
                        }
                }


                // if move to is out of range
                if (moveTo.column >= TetrisGame.initValues.validatedColumnsCount || moveTo.column &lt; 0) {
                    return false;
                }


                //let destinationEl = document.getElementById("grid" + moveTo.row + "_" + moveTo.column) || null;
                let destinationEl = TetrisGame.playBoard.querySelector(".row_" + moveTo.row + " .column_" + moveTo.column) || null;
                if (moveTo.row >= TetrisGame.config.rows || (destinationEl.innerText.trim() !== "")) {

                    if (isBottomMove) {

                        TetrisGame.matrix[moveTo.row-1][moveTo.column] = charBlock.char;
                        console.log(TetrisGame.matrix);

                        // stop interval and request new char
                        TetrisGame.interval.clear(charBlock.interval);

                        // check words
                        TetrisGame.checkWordSuccess(charBlock);

                        if (charBlock.row !== 0) {

                            if (TetrisGame.initValues.wordsFinished) {
                                TetrisGame.finishGame("finishWords");
                            } else {
                                // add new char
                                TetrisGame.characterFactory();
                            }
                        } else {
                            TetrisGame.finishGame("gameOver");
                        }
                    }

                } else {

                    // remove char with animation
                    charBlock.destroy(charBlock.element, moveTo.animateOutClass);

                    // update current char info
                    charBlock.row = moveTo.row;
                    charBlock.column = moveTo.column;
                    charBlock.animateInClass = moveTo.animateInClass;

                    // add our char in destination
                    TetrisGame.characterFactory(charBlock, destinationEl);
                }

                // play move char
                Sound.playByKey('moveChar' , TetrisGame.config.playEventsSound);

            };


            // interval
            charBlock.interval = TetrisGame.interval.make(
                () => {
                    if (!TetrisGame.initValues.paused) {
                        charBlock.move(40);
                    }
                },
                TetrisGame.config.charSpeed / TetrisGame.config.level
            );


            // destroy current character
            charBlock.destroy = function (workingElement, outgoingAnimation) {
                let animateClass = TetrisGame.config.useAnimationFlag ? " animated " : "";
                workingElement.className += animateClass + outgoingAnimation;
                setTimeout(
                    () => {
                        // remove current char
                        workingElement.parentNode.removeChild(workingElement);
                    },
                    (TetrisGame.config.useAnimationFlag ? 200/TetrisGame.config.level : 0)
                );
            };


            // create and show up coming char
            TetrisGame.showUpCommingChar();

            // add this char to active chars
            TetrisGame.initValues.activeChar = charBlock;

            return charBlock;
        },


        /**
         * Create and show upcoming character
         */
        showUpCommingChar: function () {

            TetrisGame.initValues.nextChar = TetrisGame.chooseChar();

            let upCommingCharHolder = document.querySelector(".showUpComingLetter");
            let upcommingCharEl = document.createElement('span');
            let animateClass = TetrisGame.config.useAnimationFlag ? " animated bounceIn" : "";

            upCommingCharHolder.innerHTML = '';
            upcommingCharEl.className = animateClass;
            upcommingCharEl.innerHTML = TetrisGame.initValues.nextChar || "";
            upCommingCharHolder.appendChild(upcommingCharEl);
        },


        /**
         * Choose random words in game build to work with
         */
        chooseWord: function () {
            let keys = Object.keys(window.TetrisWords);
            let randomKey = keys[keys.length * Math.random() &lt;&lt; 0];
            let value = window.TetrisWords[randomKey] || "";


            // do we finished words ?
            if (value === "" &amp;&amp; !TetrisGame.initValues.finished) {
                TetrisGame.initValues.wordsFinished = true;
                return false;
            }


            value.word = value.word.replace(/[^a-zA-ZØ¢-ÛŒ]/g, "");

            // use lower case of characters
            if(TetrisGame.config.useLowercase){
                value.word = value.word.toLowerCase();
            }

            log(value);

            // delete choosed word form list
            delete window.TetrisWords[randomKey];
            return value;
        },


        /**
         * Choose a char of choosed words
         */
        chooseChar: function () {

            let choosedChar;
            let availableChars = TetrisGame.initValues.choosedWords.map(function (e) {
                return e ? e.word : ""
            }).join('');

            TetrisGame.initValues.choosedWordsUsedChars.forEach(function (value) {
                availableChars = availableChars.replace(value, '');
            });

            if (availableChars.length === 0) {
                let newWord = TetrisGame.chooseWord();
                if (newWord !== false) {
                    TetrisGame.initValues.choosedWords.push(newWord);
                    return TetrisGame.chooseChar();
                }
            } else {
                choosedChar = availableChars[Math.random() * availableChars.length &lt;&lt; 0];
                TetrisGame.initValues.choosedWordsUsedChars.push(choosedChar);

                return choosedChar;
            }
        },




        /**
         * Get a valid column number [min-max]
         */
        getValidColumnsNumber: function () {
            let columnsNumber = TetrisGame.config.columnsMin;
            for (let i = Object.keys(window.TetrisWords).length - 1; i >= 0; i--) {
                if(window.TetrisWords[i]) {
                    let thisWordLength = window.TetrisWords[i].word.length;
                    if (thisWordLength > columnsNumber) {
                        columnsNumber = thisWordLength;
                    }
                }
            }

            // plus 2 extra block than max word length
            columnsNumber += 2;
            columnsNumber = TetrisGame.config.columnsMax &lt; columnsNumber ? TetrisGame.config.columnsMax : columnsNumber;
            return columnsNumber % 2 === 0 ? columnsNumber : columnsNumber + 1;
        },


        /**
         * Check if could find a success word
         * @param {charBlock} lastChar
         */
        checkWordSuccess: function (lastChar) {
            checkSuccess(TetrisGame.matrix,TetrisGame.initValues.choosedWords,lastChar.row,lastChar.column);
            // @todo: if okay : remove chars from Tetris.choosedWordsUsedChars and word from Tetris.choosedWords
        },


        /**
         * Factory of character
         * @param char
         * @param initializeElement
         */
        characterFactory: function (char, initializeElement) {

            // if char is not supplied create new one
            if (typeof char === "undefined") {

                char = new TetrisGame.charBlock();

                if (Object.keys(char).length !== 0) {
                    initializeElement = TetrisGame.playBoard.querySelector(".row_" + char.row + " .column_" + char.column);
                } else {
                    return false;
                }
            }

            let charBlock = document.createElement('span');
            let animateClass = TetrisGame.config.useAnimationFlag ? " animated " : "";

            charBlock.style.background = char.color;
            charBlock.innerHTML = char.name;
            charBlock.className = "charBlock " + animateClass + (char.animateInClass || "");

            char.element = charBlock;

            initializeElement.innerHTML = '';
            initializeElement.appendChild(charBlock);

        },


        /**
         * Manage btn parts buttons
         * @param showClassed
         * @param hideClasses
         */
        buttonManager: function (showClassed, hideClasses) {
            let gameBtnControl = document.querySelector(".gameControlButtons");
            gameBtnControl.querySelectorAll(showClassed).forEach((item) => {
                item.style.display = "inline-block";
            });
            gameBtnControl.querySelectorAll(hideClasses).forEach((item) => {
                item.style.display = "none";
            });
        },


        /**
         * Set settings from localStorage OR settings Object
         * @param settings
         */
        setSettings: function (settings) {


            if(typeof settings !== "undefined"){

                // save setting data
                Storage.set("settings" , settings);

            }else{
                settings = Storage.getJson('settings' , false);
                if(!settings){
                    return false;
                }
            }


            TetrisGame.config.useAnimationFlag = parseInt(settings.useAnimation) === 1;
            TetrisGame.config.playEventsSound = parseInt(settings.eventSounds) === 1;
            TetrisGame.config.playBackgroundSound = parseInt(settings.soundPlay) === 1;
            TetrisGame.config.showGrids = parseInt(settings.showGrids) === 1;
            TetrisGame.config.level = parseInt(settings.gameLevel) || 1;



            // pause/play background music
            if(!TetrisGame.config.playBackgroundSound){
                TetrisGame.initValues.bgSound.pause();
            }else{
                TetrisGame.initValues.bgSound.play();
            }


            // manage grids on play board
            if(TetrisGame.playBoard) {
                if (TetrisGame.config.showGrids) {
                    TetrisGame.playBoard.classList.add("showGrids");
                } else {
                    TetrisGame.playBoard.classList.remove("showGrids");
                }
            }

            // add level class to body AND do staffs about leveling
            let bodyClass = "";
            switch(settings.gameLevel){
                case 3:
                    bodyClass = "isExpert";

                    // use two word  same time at hard mode
                    TetrisGame.config.workingWordCount = 2;

                    break;
                case 2:
                    bodyClass = "isMedium";
                    break;
                default:
                    bodyClass = "isSimple";
            }
            document.body.classList.remove("isExpert" , "isMedium" , "isSimple");
            document.body.classList.add(bodyClass);
        },


        /**
         * Show game settings
         */
        showSetting: function () {

            // get defined settings
            let settings = Storage.getJson('settings' , {
                soundPlay : 1,
                eventSounds : 1,
                useAnimation : 1,
                gameLevel : 1,
                showGrids : 0
            });

            // pause game timer
            TetrisGame.timer.pause();

            // should we animate span ?
            let spanAnimationClass = (TetrisGame.config.useAnimationFlag ? " animatedSpan" : "");


            // create setting modal content
            let content =
                '&lt;form id="settingForm" class="cssRadio ' + spanAnimationClass + '">' +
                    '&lt;div class="formRow">' +
                        '&lt;div class="formLabel">&lt;i class="linearicon linearicon-music-note2">&lt;/i> ' + lang.backgroundMusic + '&lt;/div>' +
                        '&lt;div class="formData">' +
                            '&lt;input id="soundPlayYes" type="radio" name="soundPlay" value="1" ' + (settings.soundPlay === 1 ? "checked" : "") + ' />' +
                            '&lt;label for="soundPlayYes">&lt;span>' + lang.active + '&lt;/span>&lt;/label>' +
                            '&lt;input id="soundPlayNo" type="radio" name="soundPlay" value="0" ' + (settings.soundPlay === 0 ? "checked" : "") + ' />' +
                            '&lt;label for="soundPlayNo">&lt;span>' + lang.deActive + '&lt;/span>&lt;/label>' +
                        '&lt;/div>' +
                    '&lt;/div>' +

                    '&lt;div class="formRow">' +
                        '&lt;div class="formLabel">&lt;i class="linearicon linearicon-music-note">&lt;/i> ' + lang.eventsMusic + '&lt;/div>' +
                        '&lt;div class="formData">' +
                            '&lt;input id="eventSoundsYes" type="radio" name="eventSounds" value="1" ' + (settings.eventSounds === 1 ? "checked" : "") + ' />' +
                            '&lt;label for="eventSoundsYes">&lt;span>' + lang.active + '&lt;/span>&lt;/label>' +
                            '&lt;input id="eventSoundsNo" type="radio" name="eventSounds" value="0" ' + (settings.eventSounds === 0 ? "checked" : "") + ' />' +
                            '&lt;label for="eventSoundsNo">&lt;span>' + lang.deActive + '&lt;/span>&lt;/label>' +
                        '&lt;/div>' +
                    '&lt;/div>' +


                    '&lt;div class="formRow">' +
                        '&lt;div class="formLabel">&lt;i class="linearicon linearicon-magic-wand">&lt;/i> ' + lang.animation + '&lt;/div>' +
                        '&lt;div class="formData">' +
                            '&lt;input id="useAnimationYes" type="radio" name="useAnimation" value="1" ' + (settings.useAnimation === 1 ? "checked" : "") + ' />' +
                            '&lt;label for="useAnimationYes">&lt;span>' + lang.active + '&lt;/span>&lt;/label>' +
                            '&lt;input id="useAnimationNo" type="radio" name="useAnimation" value="0" ' + (settings.useAnimation === 0 ? "checked" : "") + ' />' +
                            '&lt;label for="useAnimationNo">&lt;span>' + lang.deActive + '&lt;/span>&lt;/label>' +
                        '&lt;/div>' +
                    '&lt;/div>' +

                    '&lt;div class="formRow">' +
                        '&lt;div class="formLabel">&lt;i class="linearicon linearicon-grid">&lt;/i> ' + lang.showGrids + '&lt;/div>' +
                        '&lt;div class="formData">' +
                            '&lt;input id="showGridsYes" type="radio" name="showGrids" value="1" ' + (settings.showGrids === 1 ? "checked" : "") + ' />' +
                            '&lt;label for="showGridsYes">&lt;span>' + lang.active + '&lt;/span>&lt;/label>' +
                            '&lt;input id="showGridsNo" type="radio" name="showGrids" value="0" ' + (settings.showGrids === 0 ? "checked" : "") + ' />' +
                            '&lt;label for="showGridsNo">&lt;span>' + lang.deActive + '&lt;/span>&lt;/label>' +
                        '&lt;/div>' +
                    '&lt;/div>' +


                    '&lt;div class="formRow">' +
                        '&lt;div class="formLabel">&lt;i class="linearicon linearicon-game">&lt;/i> ' + lang.gameLevel + '&lt;/div>' +
                        '&lt;div class="formData">' +
                            '&lt;input id="gameLevelEasy" type="radio" name="gameLevel" value="1" ' + (settings.gameLevel === 1 ? "checked" : "") + ' />' +
                            '&lt;label for="gameLevelEasy">&lt;span>'+ lang.simple + '&lt;/span>&lt;/label>' +
                            '&lt;input id="gameLevelMedium" type="radio" name="gameLevel" value="2" ' + (settings.gameLevel === 2 ? "checked" : "") + ' />' +
                            '&lt;label for="gameLevelMedium">&lt;span>'+ lang.medium + '&lt;/span>&lt;/label>' +
                            '&lt;input id="gameLevelExpert" type="radio" name="gameLevel" value="3" ' + (settings.gameLevel === 3 ? "checked" : "") + ' />' +
                            '&lt;label for="gameLevelExpert">&lt;span>' + lang.expert + '&lt;/span>&lt;/label>' +
                        '&lt;/div>' +
                    '&lt;/div>' +

                '&lt;/form>';

            // show setting modal
            let settingModal = new Modal({
                animate : TetrisGame.config.useAnimationFlag,
                header : lang.settingModalTitle,
                content : content,
                onDestroy : function () {
                    // resume timer
                    TetrisGame.timer.resume();
                },
                buttons : [
                    {
                        text : lang.save,
                        isOk : true,
                        onclick : function () {

                            // start timer
                            TetrisGame.timer.resume();

                            // catch data
                            let settingForm = document.querySelector("#settingForm");
                            let settingData = {};
                            settingData.soundPlay = parseInt(settingForm.querySelector('[name="soundPlay"]:checked').value);
                            settingData.eventSounds = parseInt(settingForm.querySelector('[name="eventSounds"]:checked').value);
                            settingData.useAnimation = parseInt(settingForm.querySelector('[name="useAnimation"]:checked').value);
                            settingData.gameLevel = parseInt(settingForm.querySelector('[name="gameLevel"]:checked').value);
                            settingData.showGrids = parseInt(settingForm.querySelector('[name="showGrids"]:checked').value);

                            // apply setting and save it
                            TetrisGame.setSettings(settingData);

                            // remove modal
                            settingModal.destroy();
                        }
                    },
                    {
                        text : lang.close,
                        onclick : function () {
                            settingModal.destroy();
                        }
                    }
                ]
            }, lang.rtl );

            settingModal.show();
        },


        /**
         * Start Game play
         */
        startGamePlay: function () {

            TetrisGame.playBoard = document.querySelector(".playBoard");

            // Get valid column length based on max json word length to create columns
            TetrisGame.initValues.validatedColumnsCount = TetrisGame.getValidColumnsNumber();

            // add class to have playBoard columns
            TetrisGame.playBoard.classList.add('is' + TetrisGame.initValues.validatedColumnsCount + 'Column');


            // show game play board girds
            if(TetrisGame.config.showGrids){
                TetrisGame.playBoard.classList.add("showGrids");
            }


            // create game columns and rows - matrix
            let playBoardTable = '';
            let matrixRowArray = [];
            for (let r = 0; r &lt; TetrisGame.config.rows; r++) {
                let matrixColumn = [];
                playBoardTable += '&lt;div class="isRow row_' + r + '">';
                for (let c = 0; c &lt; TetrisGame.initValues.validatedColumnsCount; c++) {
                    playBoardTable += '&lt;div id="grid' + r + '_' + c +  '" class="isColumn column_' + c + '" data-row="' + r + '">&lt;/div>';
                    matrixColumn[c]=' ';
                }
                matrixRowArray[r] = matrixColumn;
                playBoardTable += '&lt;/div>';
            }

            TetrisGame.matrix = matrixRowArray;

            TetrisGame.playBoard.innerHTML = playBoardTable;


            // Choose n words from json to create rows and columns
            for (let i = 0; i &lt; TetrisGame.config.workingWordCount; i++) {
                let choosedWord = TetrisGame.chooseWord();
                if(!choosedWord){
                    TetrisGame.finishGame("finishWords");
                }else {
                    TetrisGame.initValues.choosedWords.push(choosedWord);
                }
            }


            // start game timer
            TetrisGame.timer.start();


            // create first char block
            TetrisGame.characterFactory();


            // play start sound
            Sound.playByKey('start', TetrisGame.config.playEventsSound);

            // arrow keys press
            document.onkeydown = function (e) {
                if(!TetrisGame.initValues.paused) {
                    TetrisGame.initValues.activeChar.move(e.keyCode);
                }
            };

            // mobile swipe detect
            TetrisGame.swipe = new Swipe(TetrisGame.playBoard , function (dir) {

                // simulate arrow press on swipe
                switch (dir){
                    case "left":
                        TetrisGame.initValues.activeChar.move(CONTROL_CODES.LEFT);
                        break;
                    case "right":
                        TetrisGame.initValues.activeChar.move(CONTROL_CODES.RIGHT);
                        break;
                    case "down":
                        TetrisGame.initValues.activeChar.move(CONTROL_CODES.DOWN);
                        break;
                }
            });


            TetrisGame.buttonManager('.pauseGame,.restartGame', '.startGame,.resumeGame');
        },


        /**
         * Pause Game play
         */
        pauseGamePlay: function () {

            // playByKey resume sound
            Sound.playByKey('pause', TetrisGame.config.playEventsSound);

            // manage game buttons
            TetrisGame.buttonManager('.resumeGame,.restartGame', '.startGame,.pauseGame');

            // stop timer [will stop whole game]
            TetrisGame.timer.pause();
        },


        /**
         * Resume Game play
         */
        resumeGamePlay: function () {

            // playByKey resume sound
            Sound.playByKey('pause', TetrisGame.config.playEventsSound);

            // manage game buttons
            TetrisGame.buttonManager('.pauseGame,.restartGame', '.startGame,.resumeGame');

            // resume timer [will resume whole game]
            TetrisGame.timer.resume();
        },


        /**
         * Reset Game play
         */
        restartGamePlay: function () {

            // kill all intervals
            TetrisGame.interval.clearAll();

            // make game variables that variables was on start
            TetrisGame.initValues = {
                paused: false,
                finished: false,
                wordsFinished: false,
                isFirstRun: false,              // it is not first run
                chooseedWordKind: {
                    persianTitle: TetrisGame.initValues.chooseedWordKind.persianTitle,
                    englishTitle: TetrisGame.initValues.chooseedWordKind.englishTitle
                },
                bgSound : TetrisGame.initValues.bgSound ,


                validatedColumnsCount: 0,       // Count of columns which are validated
                nextChar: '',                   // Next character
                activeChar: {},                 // Active character [not stopped] Object index
                choosedWords: [],               // Choosed words to work with them
                choosedWordsUsedChars: []       // Chars that used from choosed words
            };

            // destroy swiper
            TetrisGame.swipe.destroy();

            // play resume sound
            Sound.playByKey('pause' , TetrisGame.config.playEventsSound);

            // remove old listener of keydown which causes multiple moves
            document.onkeydown = null;

            // re-build game
            TetrisGame.build();
        },


        /**
         * Game is finished [gameOver OR finishWords]
         * @param mode
         */
        finishGame: function (mode) {


            // play finish sound
            Sound.playByKey('finishGame', TetrisGame.config.playEventsSound);


            // manage game buttons
            TetrisGame.buttonManager('.restartGame', '.startGame,.pauseGame,.resumeGame');

            TetrisGame.initValues.finished = true;
            TetrisGame.timer.pause();

            let modalHeader = "", modalContent = "";
            let modalButtons = [];
            if (mode === "gameOver") {
                modalHeader = lang.gameOverModalTitle;
                modalContent = lang.gameOverModalContent;

                modalButtons.push(
                    {
                        text : lang.restartGame,
                        isOk : true,
                        onclick : function () {
                            modal.destroy();
                            TetrisGame.restartGamePlay();
                        }
                    },{
                        text : lang.modalOkButton,
                        onclick : function () {
                            modal.destroy();
                        }
                    }
                );
            } else {
                modalHeader = lang.noExtraWordModalTitle;
                modalContent = lang.noExtraWordModalContent;
                modalButtons.push(
                    {
                        text : lang.modalRefreshButton,
                        onclick : function () {
                            window.location.reload();
                        }
                    }
                );
            }

            let modal = new Modal({
                animate : TetrisGame.config.useAnimationFlag,
                header : modalHeader,
                content : modalContent,
                buttons : modalButtons
            }, lang.rtl );

            setTimeout(() => {
                modal.show();
            } , 300);

        },



        /**
         * Select editor element with class search emoji
         * @type {HTMLElement | null}
         */
        build: function () {

            // blob for timer
            blobTiming = new Blob([
                document.querySelector('#workerTiming').textContent
            ], { type: "text/javascript" });


            // set Timer instance to current TetrisGame.timer
            TetrisGame.timer = new Timer({
                blobTiming: blobTiming,
                onStart: function () {
                    TetrisGame.initValues.paused = false;
                },
                workerOnMessage: function (event) {
                    Storage.set('seconds', event.data);
                },
                onPause: function () {
                    TetrisGame.initValues.paused = true;
                },
                onResume: function () {
                    TetrisGame.initValues.paused = false;
                }
            });


            TetrisGame.interval = new Interval();



            // make ltr if used lang is ltr
            let ltrClass = "";



            TetrisGame.controlCodes = {
                LEFT:   CONTROL_CODES.LEFT,
                RIGHT:  CONTROL_CODES.RIGHT,
                DOWN:   CONTROL_CODES.DOWN
            };


            if (!lang.rtl) {
                ltrClass = "isLtr";

                // In LTR languages, Left and Right should be swapped
                TetrisGame.controlCodes = {
                    RIGHT:  CONTROL_CODES.LEFT,
                    LEFT:   CONTROL_CODES.RIGHT,
                    DOWN:   CONTROL_CODES.DOWN
                }
            }


            if(TetrisGame.initValues.isFirstRun){
                TetrisGame.initValues.bgSound = new Sound("background").play();
                TetrisGame.initValues.isFirstRun = false;
            }

            // set game settings from local storage
            TetrisGame.setSettings();


            // add main html to page
            document.querySelector("#container").innerHTML =
                `&lt;div class="gameHolder ${ltrClass}">
                    &lt;div class="behindPlayBoard">
                        &lt;div class="gamingKind">&lt;span class="persian">${TetrisGame.initValues.chooseedWordKind.persianTitle}&lt;/span>&lt;span class="english">${TetrisGame.initValues.chooseedWordKind.englishTitle}&lt;/span>&lt;/div>
                        &lt;div class="showUpComingLetter" title="${lang.nextLetter}:">&lt;/div>
                        &lt;div class="gameControlButtons" >
                            &lt;div onclick="TetrisGame.startGamePlay();" class="startGame">${lang.startGame}&lt;/div>
                            &lt;div onclick="TetrisGame.pauseGamePlay();" class="pauseGame" style="display: none">${lang.pauseGame}&lt;/div>
                            &lt;div onclick="TetrisGame.resumeGamePlay();" class="resumeGame" style="display: none">${lang.resumeGame}&lt;/div>
                            &lt;div onclick="TetrisGame.restartGamePlay();" class="restartGame" style="display: none">${lang.restartGame}&lt;/div>
                        &lt;/div>
                       &lt;div class="courseArea">
                           &lt;div class="setting" onclick="TetrisGame.showSetting();">&lt;i class="linearicon linearicon-cog">&lt;/i> ${lang.settings}&lt;/div>
                           &lt;div >&lt;i class="linearicon linearicon-bag-pound">&lt;/i> ${lang.score} : 0&lt;/div>
                           &lt;div >&lt;i class="linearicon linearicon-mustache-glasses">&lt;/i> ${lang.createdWords} : 0&lt;/div>
                           &lt;div >&lt;i class="linearicon linearicon-clock">&lt;/i> ${lang.spentTime} : &lt;span class="timerDisplay">0&lt;/span>&lt;/div>
                       &lt;/div>
                   &lt;/div>
                   &lt;div class="playBoard">&lt;span class="emptyPlayBoard">${lang.clickStartGame}&lt;/span>&lt;/div>
                &lt;/div>
                &lt;footer class="page-footer">
                    &lt;div class="container">
                        &lt;i class="linearicon linearicon-brain">&lt;/i> ${lang.copyRight}
                    &lt;/div>
                &lt;/footer>`;
        }
    };

    if (typeof module !== 'undefined' &amp;&amp; typeof module.exports !== 'undefined') {
        module.exports = TetrisGame;
    } else if (TetrisGame.isBrowser) {
        window.TetrisGame = TetrisGame;
    }

})();
</code></pre>
        </article>
    </section>




</div>

<footer>
    <img class="logo" src="./img/logo.png" style="width: 200px; height: 85px">
    <div class="footer-text">Made with <3 by ArshTeam. Documented with JsDoc3, TuiTheme.</div>
</footer>
<script>prettyPrint();</script>
<script src="scripts/jquery.min.js"></script>
<script src="scripts/tui-doc.js"></script>
<script src="scripts/linenumber.js"></script>

    <script>
        var id = '_sub'.replace(/"/g, '_');
        var selectedApi = document.getElementById(id); // do not use jquery selector
        var $selectedApi = $(selectedApi);

        $selectedApi.removeClass('hidden');
        $selectedApi.parent().find('.glyphicon').removeClass('glyphicon-plus').addClass('glyphicon-minus');
        showLnbApi();
    </script>

</body>
</html>
